/*
 * generated by Xtext 2.28.0
 */
package br.edu.unijui.gca.jabuti.generator

import br.edu.unijui.gca.jabuti.generator.entities.StructVar
import br.edu.unijui.gca.jabuti.generator.entities.VarExpr
import br.edu.unijui.gca.jabuti.generator.entities.VarTerm
import br.edu.unijui.gca.jabuti.generator.entities.terms.TermStruct
import br.edu.unijui.gca.jabuti.generator.entities.terms.TimeInterval_S
import br.edu.unijui.gca.jabuti.generator.entities.terms.MaxNumberOfOperationByTime_S
import br.edu.unijui.gca.jabuti.generator.entities.terms.MaxNumberOfOperation_S
import br.edu.unijui.gca.jabuti.generator.entities.terms.MessageContent_Boolean_S
import br.edu.unijui.gca.jabuti.generator.entities.terms.MessageContent_Number_PerTime_S
import br.edu.unijui.gca.jabuti.generator.entities.terms.MessageContent_Number_S
import br.edu.unijui.gca.jabuti.generator.entities.terms.MessageContent_String_S
import br.edu.unijui.gca.jabuti.generator.entities.terms.MessageContent_onlyXPath_Boolean_S
import br.edu.unijui.gca.jabuti.generator.entities.terms.MessageContent_onlyXPath_Number_S
import br.edu.unijui.gca.jabuti.generator.entities.terms.MessageContent_onlyXPath_String_S
import br.edu.unijui.gca.jabuti.generator.entities.terms.SessionInterval_S
import br.edu.unijui.gca.jabuti.generator.entities.terms.Timeout_S
//imports from Jabuti DSL
import br.edu.unijui.gca.jabuti.jabuti.BinaryOperator
import br.edu.unijui.gca.jabuti.jabuti.BinaryTermOperator
import br.edu.unijui.gca.jabuti.jabuti.Clause
import br.edu.unijui.gca.jabuti.jabuti.Contract
import br.edu.unijui.gca.jabuti.jabuti.Expression
import br.edu.unijui.gca.jabuti.jabuti.ExpressionTerm
import br.edu.unijui.gca.jabuti.jabuti.LiteralValue
import br.edu.unijui.gca.jabuti.jabuti.MaxNumberOfOperation
import br.edu.unijui.gca.jabuti.jabuti.MessageContent
import br.edu.unijui.gca.jabuti.jabuti.NumericValue
import br.edu.unijui.gca.jabuti.jabuti.ParenthesizedExpression
import br.edu.unijui.gca.jabuti.jabuti.StringValue
import br.edu.unijui.gca.jabuti.jabuti.Term
import br.edu.unijui.gca.jabuti.jabuti.UnaryOperator
import br.edu.unijui.gca.jabuti.jabuti.VariableValue
//imports from Java
import java.text.SimpleDateFormat
import java.util.ArrayList
import java.util.LinkedHashMap
import java.util.List
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import br.edu.unijui.gca.jabuti.jabuti.SessionInterval
import br.edu.unijui.gca.jabuti.jabuti.TimeInterval
// import of data libraries
import java.sql.Timestamp;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.LocalDate;
import br.edu.unijui.gca.jabuti.jabuti.Timeout
import br.edu.unijui.gca.jabuti.jabuti.WeekDaysInterval
import br.edu.unijui.gca.jabuti.generator.entities.terms.WeekDaysInterval_S
import br.edu.unijui.gca.jabuti.jabuti.Right
import br.edu.unijui.gca.jabuti.jabuti.Obligation
import br.edu.unijui.gca.jabuti.jabuti.Prohibition
import java.util.HashMap
import br.edu.unijui.gca.jabuti.jabuti.Variable
import org.eclipse.emf.common.util.EList
import br.edu.unijui.gca.jabuti.jabuti.DataType
import br.edu.unijui.gca.jabuti.jabuti.NegationOperator

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class JabutiGenerator extends AbstractGenerator {

	static var comparison_symbols = newArrayList
	static var logical_symbols = newArrayList
	static var math_symbols = newArrayList
	static var unary_symbols = newArrayList
	ArrayList<ClauseStruct> clauses

	LinkedHashMap<String, StructVar> variablesMap
	ArrayList<String> exprContent_temp
//	String exprVarName_temp	
	int counter;
	int paramCounter_if;
//	ArrayList<String> terms = newArrayList
	ArrayList<String> termsTypesInUse;

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val c = resource.allContents.filter(Contract).head
		fsa.generateFile(c.name + '.sol', generateSolCode(c))
// If a file can contain more than one contract, you need to iterate over the resource.	
//		for (c : resource.allContents.filter(Contract).toIterable) {
//			fsa.generateFile(c.name + '.sol', generateSolCode(c))
//		}

	}


	def generateSolCode(Contract ct) {

		comparison_symbols.addAll(#["<=", ">=", ">", "<", "!=", "=="])
		logical_symbols.addAll(#["AND", "OR"])
		math_symbols.addAll(#["+", "-", "*", "/"])
		unary_symbols.addAll(#["-", "!"])
		// variables_map.clear
		exprContent_temp = new ArrayList<String>
		variablesMap = new LinkedHashMap<String, StructVar>
		clauses = new ArrayList<ClauseStruct>
		termsTypesInUse = newArrayList

		if (ct !== null) {
			resetCounter // define um contador de clausula como zero, dentro do mapping ele será incrementado
			for (c : ct.clauses) {
				this.mappingClauses(c)
			}
			resetCounter // voltar o valor de counter para zero
			for (v : ct.variables) {
				if (v.term !== null) {
					v.term.getVariableContent_Term(v.name)
				} else if (v.expression !== null) {
					v.expression.getVariable_ExpressionType(v.name)
				}
			}

			getTheTypesOfTermsInUse // this method populate the arraylist termsTypesInUse
		}


		'''
//SPDX-License-Identifier: MIT
pragma solidity ^0.8.14;
import "./libs/EAI.sol";

contract «ct.name» {
«"\n"»
«"\t"»bool activated;
«"\t"»uint32 beginDate; 
«"\t"»uint32 dueDate; 	
«"\t"»using EAI for EAI.Party;

«"\t"»EAI.Party application;
«"\t"»EAI.Party process;
«"\t"»mapping(address=>EAI.Party) mapParty;

«"\t"»event failEvent(string _logMessage);
«"\t"»event successEvent(string _logMessage);

«««/* --------------------------- END: commom code for all contracts ----------------------- */ 
«««/* =========== BEGIN: codes generated based in specific jabuti contract =================== */
«IF ct !== null»
«««/*----------------- 1º STEP: ADD IMPORTS TO THE TERMS USED IN THE CONTRACT ---------------*/
 	«FOR t: termsTypesInUse»
      	«"\t"»using EAI for EAI.«t.removeTermSuffix»;
 	«ENDFOR»	
 
«««»
«««/*---------------- 2º STEP: Declare the variables (from variables block) -------------------------*/
	«FOR v : variablesMap.values»
		«IF v instanceof VarTerm»
      	«"\t"»EAI.«v.type.removeTermSuffix» «v.name»;
		«ELSE»
      	«"\t"»«v.type.toFirstLower» «v.name»;
		«ENDIF»
	«ENDFOR»

«««
«««/*---------------- 3º STEP: Identify and declare variables referring to the clauses terms --------------*/
	«FOR clause : clauses»	
		«"\t"»//---------------- Vectors of terms related to the «clause.name» clause(_C«clause.id»). ----------------
		«var listOfTermsTypeUnique = clause.termsList.getTermTypeUniqueValues»
		«FOR termType: listOfTermsTypeUnique»			
	 	«"\t"»«"EAI."+termType.removeTermSuffix+"[]"» «termType.removeTermSuffix.toFirstLower+"_C"+ clause.id»;
	 	«ENDFOR»«"\n"»
	«ENDFOR»	
«««
«««/*---------------- 4º STEP: Create the constructor method ------------------------------------------*/» 
	constructor(address _applicationWallet){
		activated = true;		
		beginDate = «ct.beginDate.toTimestamp»;
		dueDate = «ct.dueDate.toTimestamp»;
		application = EAI.createParty("«ct.application.name»", _applicationWallet, false);             
		process = EAI.createParty("«ct.process.name»", msg.sender, true);    
		mapParty[msg.sender] = process;
		mapParty[_applicationWallet] = application;
		«"\n"»
		// Create and assign the values to variables related to the variables from jabuti and the terms of the clauses
		«assignValuesToVariablesRelatedToJabutiVariablesAndTerms(ct.variables)»
	}
«««	
«««/*---------------- 5º STEP: Create the functions related to each function ------------------------------------------*/»»	
	«FOR c : clauses»	
	«««Define the name of the functions and their parameters»»	
	«"\n"»
	«var listOfParameters = c.termsList.buildParameterForFunction»
	«"\t"»function «c.type»_«c.name»(
	«FOR termType: listOfParameters»	
		«IF termType.isTheLastTermType(listOfParameters)»
			«"\t\t"»«termType»
		«ELSE»
			«"\t\t"»«termType»,
		«ENDIF»
	«ENDFOR»
«"\t\t"») public «IF c.rolePlayer == "PROCESS"»onlyProcess()«ELSE»onlyApplication()«ENDIF» returns(bool){
	«IF c.rolePlayer == "APPLICATION"»
		«"\t\t"»require(mapParty[msg.sender].isAware(), "The Application party should sign the contract before interact with it.");	   	 
	«ENDIF»
	«««	
	«««GERADOR DOS IF STATEMENT»»
«"\t"»«generateIfStatementBaseInTheTermsOfTheClause(c)»
«"\t"»}««« end of the function»
«"\n"»
«incrementCounter» «««contador utilizado identificar o numero da clausula atual dentro do for»
	«ENDFOR»
	«resetCounter»	
«ENDIF»	
«««
«««/* -------------- END: codes generated based in specific jabuti contract ------------- 
«««/*---------------- 6º STEP: Insert the code common to all contracts  ------------------------------------------*/»»	
«insertTheCodeCommonToAllContracts»
    
}
'''
	}
	
	def insertTheCodeCommonToAllContracts(){
		'''
		«"\t"»/* the process sign the contract by default, the function signContract 
		    is used to get the applicationParty signature*/      
		    function signContract() public onlyApplication() returns(bool) {
		        require(application.aware == false, "The contract is already signed");        
		        application.aware = true;  
		        updateMapParty(msg.sender, application);
				return true;
		    }
		 
		    function updateMapParty(address _walletAddress, EAI.Party storage _party)internal returns(bool){       
		        mapParty[_walletAddress] = _party;
				return true;
		    }
		    
		    /* It only possible to change the name and the address of the party. 
		    After change the  party, the new party need to sign the contract */
		    function changeApplicationParty(string memory _name, address _walletAddress) public returns(bool) {       
		        require(process.walletAddress == msg.sender, "Only the process can execute this operation");
		        delete mapParty[application.walletAddress];
		        application = EAI.createParty(_name, _walletAddress, false);          
		        updateMapParty(_walletAddress, application);
		        return true;       
		    }
		    
		    function getProcessAddress() public view onlyInvolvedParties returns(address){
		        return process.walletAddress;
		    }
		    
		    function getApplicationAddress() public view onlyInvolvedParties returns(address){
		        return application.walletAddress;
		    }
		 
		    function getParty(address _walletAddress) public view onlyInvolvedParties returns(EAI.Party memory){
		        return mapParty[_walletAddress];
		    }
		    
		    modifier onlyApplication(){        
		        require(activated, "This contract is deactivated");            
		        require(application.walletAddress == msg.sender, "Only the application can execute this operation");
		        _;        
		    }
		 
		    modifier onlyProcess(){
		        require(activated, "This contract is deactivated");
		        require(process.walletAddress == msg.sender, "Only the process can execute this operation");
		        _;
		    }
		 
		    modifier onlyInvolvedParties(){
		        require(activated, "This contract is deactivated");
		        require(
		            (application.walletAddress == msg.sender || process.walletAddress == msg.sender ) ,
		            "Only the process or the application can execute this operation");
		        _;
		    }
		'''
	}

	def assignValuesToVariablesRelatedToJabutiVariablesAndTerms(EList<Variable> variables){
		'''
		«««instanciar os variariaveis, atribuir os valores»»
			«FOR v : variables»
				«IF v.term !== null»			
					«v.name» = «"EAI.create"+variablesMap.get(v.name).type.removeTermSuffix+"("+buildCode_addParameters(variablesMap.get(v.name).type, (variablesMap.get(v.name) as VarTerm).term)+")"»;	
				«ELSEIF v.expression !== null»
					«v.name» = «(variablesMap.get(v.name) as VarExpr).content.join("")»;
				«ENDIF»
			«ENDFOR»
		«««instanciar os termos e adicionar ao vetor das respectivas clausulas»»
«resetCounter»«««zera a variavel counter»
	«FOR clause : clauses»			
		«incrementCounter»«"\n"»
		//---------------- Terms related to the «clause.name» clause (C«clause.id»). ----------------
		«FOR term: clause.termsList»
			«var typeName = term.class.simpleName»
			«typeName.removeTermSuffix.toFirstLower+"_C"+counter+".push(EAI.create"+typeName.removeTermSuffix+"("+buildCode_addParameters(typeName, term)+"))"»;
		«ENDFOR»
	«ENDFOR»
		«resetCounter»
		'''
	}
	
	def generateIfStatementBaseInTheTermsOfTheClause(ClauseStruct c){		
	'''
	«var listOfParametersForIfStatement = c.termsList.buildParameterForIfStatement»
	«reset_paramCounter_if»
	if(«FOR i:0 ..< listOfParametersForIfStatement.size»
			«IF i== (listOfParametersForIfStatement.size-1)»««« se for o ultimo»					
				«IF paramCounter_if < c.logicalOperators.size && c.logicalOperators.get(paramCounter_if)== "!"»
					«"\t\t"»!«listOfParametersForIfStatement.get(i)»
				«ELSE»
					«"\t\t"»«listOfParametersForIfStatement.get(i)»
				«ENDIF»					
			«ELSE»		
				«IF c.type == "prohibition"»
					«IF c.logicalOperators.get(paramCounter_if) !== null && c.logicalOperators.get(paramCounter_if)== "!"»
						«"\t\t"»«c.logicalOperators.get(paramCounter_if++)»«listOfParametersForIfStatement.get(i)» || «increment_paramCounter_if»
					«ELSE»
						«"\t\t"»«listOfParametersForIfStatement.get(i)» || «increment_paramCounter_if»
					«ENDIF»
				«ELSE»
					«IF c.logicalOperators.get(paramCounter_if) !== null && c.logicalOperators.get(paramCounter_if)== "!"»
						«"\t\t"»«c.logicalOperators.get(paramCounter_if++)»«listOfParametersForIfStatement.get(i)» «c.logicalOperators.get(paramCounter_if++)»						
					«ELSE»
						«"\t\t"»«listOfParametersForIfStatement.get(i)» «c.logicalOperators.get(paramCounter_if++)»
					«ENDIF»
				«ENDIF»
			«ENDIF»				
		«ENDFOR»		
	«"\t\t"»){
		«««	
		«««GERADOR DO CORPO DO IF STATEMENT»»		
			«IF clauses.get(counter).operationType == "request" && clauses.get(counter).type == "right"»
				«var id = getIdOfClauseWithOperationType("response")»
				«IF id >=0»
					«FOR term: clauses.get(id).termsList»
						«IF term instanceof Timeout_S»						
							«"\t\t"»«term.class.simpleName.removeTermSuffix.toFirstLower»_C«id+1»[0].setEndTimeInTimeout(accessDateTime); 						
						«ENDIF»
					«ENDFOR»
				«ENDIF»	
			«ENDIF»
			«var maxNumberOfOperationByTime_counter=0»
			«var maxNumberOfOperation_counter=0»
			«var messageContent_Number_PerTime_counter=0»
			«FOR term: clauses.get(counter).termsList»
				«IF term instanceof MaxNumberOfOperationByTime_S»			
		 			«"\t\t"»«term.class.simpleName.removeTermSuffix.toFirstLower»_C«counter+1»[«maxNumberOfOperationByTime_counter++»].decreaseOneOperation_ByTime(accessDateTime);
				«ELSEIF term instanceof MaxNumberOfOperation_S»
	 				«"\t\t"»«term.class.simpleName.removeTermSuffix.toFirstLower»_C«counter+1»[«maxNumberOfOperation_counter++»].decreaseOneOperation();
				«ELSEIF term instanceof MessageContent_Number_PerTime_S»
	 				«"\t\t"»«term.class.simpleName.removeTermSuffix.toFirstLower»_C«counter+1»[«messageContent_Number_PerTime_counter++»].decreaseTheLastContentOfRestingAmount();						
				«ENDIF»	
			«ENDFOR»		
			«««caso as condições sejam satifeitas»
			«IF c.type == "prohibition"»
				«IF !c.failMessage.nullOrEmpty»							
		 			«"\t\t"»emit failEvent("«c.failMessage»");
				«ENDIF»					
				«"\t\t"»return false;
			«ELSE»
				«IF !c.successMessage.nullOrEmpty»
					«"\t\t"»emit successEvent("«c.successMessage»")						
				«ENDIF»
				«"\t\t"»return true;
			«ENDIF»
	«"\t"»}else{	
			«IF clauses.get(counter).operationType == "response" && clauses.get(counter).type == "obligation"»			
				«var id = getIdOfClauseWithOperationType("request")»
				«IF id >=0»
					«FOR term: clauses.get(id).termsList»
						«IF term instanceof MaxNumberOfOperationByTime_S»
		 					«"\t\t"»«term.class.simpleName.removeTermSuffix.toFirstLower»_C«id+1»[«maxNumberOfOperationByTime_counter++»].increaseOneOperation_ByTime();
						«ELSEIF term instanceof MaxNumberOfOperation_S»
		 					«"\t\t"»«term.class.simpleName.removeTermSuffix.toFirstLower»_C«id+1»[«maxNumberOfOperation_counter++»].increaseOneOperation();
						«ELSEIF term instanceof MessageContent_Number_PerTime_S»
		 					«"\t\t"»«term.class.simpleName.removeTermSuffix.toFirstLower»_C«id+1»[«messageContent_Number_PerTime_counter++»].increaseTheLastContentInRestingAmount();						
						«ENDIF»					
					«ENDFOR»
				«ENDIF»	
			«ENDIF»
			«««caso as condições não  sejam satifeitas»
			«IF c.type == "prohibition"»
				«IF !c.successMessage.nullOrEmpty»
					«"\t\t"»emit successEvent("«c.successMessage»")						
				«ENDIF»
				«"\t\t"»return true;
			«ELSE»
				«IF !c.failMessage.nullOrEmpty»							
		 			«"\t\t"»emit failEvent("«c.failMessage»");
				«ENDIF»					
				«"\t\t"»return false;
			«ENDIF»
	«"\t"»}
	
	'''
	}	

	def int countTermOfThisType(List<TermStruct> terms, String termTypeReference){
		var int count=0;
		for (term : terms) {
			var termType = term.getClass.simpleName
			if (termType == termTypeReference) {
				count++;
			}
		}
		return count;
	}
	
	def int getIdOfClauseWithOperationType(String operationType) {
		for (i : 0 .. clauses.size-1) {			
			
			if (clauses.get(i).operationType == operationType) {			
				return i;
			}
		}				
		return -1;
	}

	def ArrayList<String> getTermTypeUniqueValues(List<TermStruct> terms) {
		val termList = new ArrayList<TermStruct>(terms)

		var termNameUnique = newArrayList

		for (term : termList) {
			var termName = term.getClass.simpleName
			if (!termNameUnique.contains(termName)) {
				termNameUnique.add(termName)
			}

		}

		return termNameUnique
	}

	def boolean isTheLastTermType(String termType, List<String> listTermsType) {
		var lastTermType = listTermsType.get(listTermsType.size - 1);
		if (termType == lastTermType) {
			return true;
		}
		return false;
	}

	def buildParameterForFunction(List<TermStruct> terms) {

		var listTermsType = terms.getTermTypeUniqueValues

		var listParemeters = newArrayList

		for (String termType_s : listTermsType) {

			if (termType_s == "MaxNumberOfOperationByTime_S" || termType_s == "Timeout_S") {
				if (!listParemeters.contains("uint32 accessDateTime")) {
					listParemeters.add("uint32 accessDateTime")
				}
			} else if (termType_s == "MaxNumberOfOperation_S") {
				// não fazer nada
			} else if (termType_s == "MessageContent_Boolean_S") {
				listParemeters.add("bool[] memory " + termType_s.toFirstLower.removeTermSuffix)
			} else if (termType_s == "MessageContent_Number_PerTime_S") {
				if (!listParemeters.contains("uint32 accessDateTime")) {
					listParemeters.add("uint32 accessDateTime")
				}
				listParemeters.add("uint256[] memory " + termType_s.toFirstLower.removeTermSuffix)
			} else if (termType_s == "MessageContent_Number_S") {
				listParemeters.add("uint256[] memory " + termType_s.toFirstLower.removeTermSuffix)
			} else if (termType_s == "MessageContent_String_S") {
				listParemeters.add("string[] memory " + termType_s.toFirstLower.removeTermSuffix)
			} else if (termType_s == "MessageContent_onlyXPath_Boolean_S") {
				listParemeters.add("bool[] memory " + termType_s.toFirstLower.removeTermSuffix)
			} else if (termType_s == "MessageContent_onlyXPath_Number_S") {
				listParemeters.add("bool[] memory " + termType_s.toFirstLower.removeTermSuffix)
			} else if (termType_s == "MessageContent_onlyXPath_String_S") {
				listParemeters.add("bool[] memory " + termType_s.toFirstLower.removeTermSuffix)
			} else if (termType_s == "TimeInterval_S") {
				if (!listParemeters.contains("uint32 accessTime")) {
					listParemeters.add("uint32 accessTime")
				}
			} else if (termType_s == "WeekDayInterval") {
				listParemeters.add("uint8[] memory " + termType_s.toFirstLower.removeTermSuffix)
			}
		}
		return listParemeters
	}

	def buildParameterForIfStatement(List<TermStruct> terms) {
		var listOfParameters = new ArrayList<String>()

		val termOccurrences = new HashMap<String, Integer>()

		var termName = ""
		for (term : terms) {
			termName = term.class.simpleName
			if (termOccurrences.containsKey(termName)) {
				termOccurrences.put(termName, termOccurrences.get(termName) + 1) // Incrementa o valor
			} else {
				termOccurrences.put(termName, 0) // Insere a chave com valor inicial 1
			}
			listOfParameters.add(termName.
				buildCode_ParametersOfThe_IfStatement_BasedInTheTermsOfTheClause(termOccurrences.get(termName)))
		}

		return listOfParameters
	}

	def buildCode_ParametersOfThe_IfStatement_BasedInTheTermsOfTheClause(String termType, int id) {
		
		var ifParameter = "";

		switch termType {
			case "MaxNumberOfOperation_S": {
				ifParameter = "maxNumberOfOperation_C" + (counter + 1) + "[" + id + "].hasAvailableOperations()"
			}
			case "MaxNumberOfOperationByTime_S": {
				ifParameter = "maxNumberOfOperationByTime_C" + (counter + 1) + "[" + id +
					"].hasAvailableOperations_ByTime(accessDateTime)"
			}
			case "MessageContent_Boolean_S": {
				ifParameter = "messageContent_Boolean_C" + (counter + 1) + "[" + id + "].evaluateBooleanContent(" +
					termType.toFirstLower.removeTermSuffix + "[" + id + "])"
			}
			case "MessageContent_Number_PerTime_S": {
				ifParameter = "messageContent_Number_PerTime_C" + (counter + 1) + "[" + id +
					"].evaluateNumberPerTime(accessDateTime," + termType.toFirstLower.removeTermSuffix + "[" + id + "])"
			}
			case "MessageContent_Number_S": {
				ifParameter = "messageContent_Number_C" + (counter + 1) + "[" + id + "].evaluateNumberContent(" +
					termType.toFirstLower.removeTermSuffix + "[" + id + "])"
			}
			case "MessageContent_onlyXPath_Boolean_S": {
				ifParameter = termType.toFirstLower.removeTermSuffix + "[" + id + "]"
			}
			case "MessageContent_onlyXPath_Number_S": {
				ifParameter = termType.toFirstLower.removeTermSuffix + "[" + id + "]"
			}
			case "MessageContent_onlyXPath_String_S": {
				ifParameter = termType.toFirstLower.removeTermSuffix + "[" + id + "]"
			}
			case "MessageContent_String_S": {
				ifParameter = "messageContent_String_C" + (counter + 1) + "[" + id + "].evaluateStringContent(" +
					termType.toFirstLower.removeTermSuffix + "[" + id + "])"
			}
			case "SessionInterval_S": {
				ifParameter = "default - implementing"
			}
			case "TimeInterval_S": {
				ifParameter = "timeInterval_C" + (counter + 1) + "[" + id + "].isIntoTimeInterval(accessTime)"
			}
			case "Timeout_S": {
				ifParameter = "!timeout_C" + (counter + 1) + "[" + id + "].isTimeoutEnded(accessDateTime)"
			}
			case "WeekDaysInterval_S": {
				ifParameter = "weekDaysInterval_C" + (counter + 1) + "[" + id + "].isIntoWeekDaysInterval(" +
					termType.toFirstLower.removeTermSuffix + "[" + id + "])"
			}
			default: {
				println("unknown: " + termType)
				return null;
			}
		}

		return ifParameter

	}

	def String buildFunctionName(Clause clause) {
		switch (clause) {
			Right: {
				return "right_" + clause.name
			}
			Obligation: {
				return "obligation_" + clause.name
			}
			Prohibition: {
				return "prohibition_" + clause.name
			}
			default: {
				return "unknown type"
			}
		}
	}

	def String getClauseType(Clause clause) {
		switch (clause) {
			Right: {
				return "right"
			}
			Obligation: {
				return "obligation"
			}
			Prohibition: {
				return "prohibition"
			}
			default: {
				return "unknown clause type"
			}
		}
	}

// ----------------------------------------------------------------------------------
//======================================================================================================
// ========================= CREATE THE TERMS TO INSERT INTO THE CONSTRUCTOR ===========================
	def String buildCode_addParameters(String type, TermStruct term) {

		switch term {
			MaxNumberOfOperation_S: {
				return " " + term.amount + " "
			}
			MaxNumberOfOperationByTime_S: {
				return " " + term.amout + ", uint8(EAI.TimeUnit." + term.timeUnit + ") "
			}
			MessageContent_Boolean_S: {
				var String xpath = term.xpath.addDoubleQuotesToXpath
				return " " + xpath + ", \"" + term.op + "\", " + term.content + " "
			}
			MessageContent_Number_PerTime_S: {
				var String xpath = term.xpath.addDoubleQuotesToXpath
				return " " + xpath + ", \"" + term.op + "\", " + term.amount + ", uint8(EAI.TimeUnit." + term.timeUnit + ") "
			}
			MessageContent_Number_S: {
				var String xpath = term.xpath.addDoubleQuotesToXpath
				return " " + xpath + ", \"" + term.op + "\", " + term.content + " "
			}
			MessageContent_onlyXPath_Boolean_S: {
				var String xpath = term.xpath.addDoubleQuotesToXpath
				return " " + xpath + " "
			}
			MessageContent_onlyXPath_Number_S: {
				var String xpath = term.xpath.addDoubleQuotesToXpath
				return " " + xpath + " "
			}
			MessageContent_onlyXPath_String_S: {
				var String xpath = term.xpath.addDoubleQuotesToXpath
				return " " + xpath + " "
			}
			MessageContent_String_S: {
				var String xpath = term.xpath.addDoubleQuotesToXpath
				return " " + xpath + ", \"" + term.op + "\", " + term.content + " "
			}
			SessionInterval_S: {
				return " " + term.duration + ", uint8(EAI.TimeUnit." + term.timeUnit + ") "
			}
			TimeInterval_S: {
				return " " + term.start + ", " + term.end + " "
			}
			Timeout_S: {
				return " " + term.amountTime + " "
			}
			WeekDaysInterval_S: {
				return " uint8(EAI.Day." + term.start + "), uint8(EAI.Day." + term.end + ") "
			}
			default: {
				return "unknown: " + term.class.simpleName
			}
		}

	}

	def String addDoubleQuotesToXpath(String xpath) {
		if (xpath.contains("/")) {
			return " \"" + xpath + "\""
		}
		return xpath
	}

//======================================================================================================
// ============================ MAPPING CLAUSES TO A HASH_MAP STRUCTURE ================================	
	def void mappingClauses(Clause c) {
		val String onSuccessMessage = c.onSuccess?.message ?: null
		val String onBreachMessage = c.onBreach?.message ?: null
		clauses.add(
			new ClauseStruct(counter + 1, c.clauseType, c.name, c.rolePlayer.getName, onBreachMessage, onSuccessMessage,
				c.operation.toString.toLowerCase))
		addTermsIntoTheClauseMap(c.terms)
		incrementCounter;
	}

	// map the terms and the logical operators
	def void addTermsIntoTheClauseMap(ExpressionTerm exprTerm) {
		switch exprTerm {
			BinaryTermOperator: {
				addTermsIntoTheClauseMap(exprTerm.left)
				// clauses.get(counter).addLogicalOperator(exprTerm.symbol)
				clauses.get(counter).addLogicalOperator(getLogicalOperator(exprTerm.symbol))
				addTermsIntoTheClauseMap(exprTerm.right)
			}
			NegationOperator: {
				// clauses.get(counter).addLogicalOperator(exprTerm.symbol)
				clauses.get(counter).addLogicalOperator(getLogicalOperator(exprTerm.symbol))
				var unary = exprTerm as NegationOperator
				addTermsIntoTheClauseMap(unary.expressionTerm)
			}
			Term: {
				var term = exprTerm as Term
				var type = term.getTermType
				var TermStruct term_S = buildTheTermStruct_S(type, term)
				
				clauses.get(counter).addTerm(term_S)
				
			}
			default: {
				println("Unknown term type: " + exprTerm)
			}
		}
	}

	def getLogicalOperator(String symbol) {
		if (symbol == "OR") {
			return "||"
		} else if (symbol == "NOT") {
			return "!"
		} else {
			return "&&"
		}
	}

	def TermStruct buildTheTermStruct_S(String typeTerm, Term term) {
		exprContent_temp.clear
		switch typeTerm {
			case "MaxNumberOfOperation_S": {
				var t = term as MaxNumberOfOperation
				return new MaxNumberOfOperation_S(t.operationsNumber)
			}
			case "MaxNumberOfOperationByTime_S": {
				var t = term as MaxNumberOfOperation
				return new MaxNumberOfOperationByTime_S(t.operationsNumber, t.perTime.timeUnit.toString.toUpperCase)
			}
			case "MessageContent_Boolean_S": {
				var t = term as MessageContent
				var String xpath = t.xpathFromMessageContent;
				var expression = t.expression.variableContent_Expression.join("") == "true" ? true : false
				return new MessageContent_Boolean_S(xpath, t.comparisonOperator.symbol, expression)
			}
			case "MessageContent_Number_PerTime_S": {
				var t = term as MessageContent
				var String xpath = t.xpathFromMessageContent;
				var expression = Integer.valueOf(t.expression.variableContent_Expression.join(""))
				return new MessageContent_Number_PerTime_S(xpath, t.comparisonOperator.symbol, expression,
					t.perTime.timeUnit.toString.toUpperCase)
			}
			case "MessageContent_Number_S": {
				var t = term as MessageContent
				var String xpath = t.xpathFromMessageContent;
				var expression = Integer.valueOf(t.expression.variableContent_Expression.join(""))
				return new MessageContent_Number_S(xpath, t.comparisonOperator.symbol, expression)

			}
			case "MessageContent_onlyXPath_Boolean_S": {
				var t = term as MessageContent
				var String xpath = t.xpathFromMessageContent;
				return new MessageContent_onlyXPath_Boolean_S(xpath)
			}
			case "MessageContent_onlyXPath_Number_S": {
				var t = term as MessageContent
				var String xpath = t.xpathFromMessageContent;
				return new MessageContent_onlyXPath_Number_S(xpath)
			}
			case "MessageContent_onlyXPath_String_S": {
				var t = term as MessageContent
				var String xpath = t.xpathFromMessageContent;
				return new MessageContent_onlyXPath_String_S(xpath)
			}
			case "MessageContent_String_S": {
				var t = term as MessageContent
				var String xpath = t.xpathFromMessageContent;
				var expression = t.expression.variableContent_Expression.join("")
				return new MessageContent_String_S(xpath, t.comparisonOperator.symbol, expression)
			}
			case "SessionInterval_S": {
				var t = term as SessionInterval
				return new SessionInterval_S(t.frequency, t.timeUnit.toString, t.value) // alem do value pode ser um messageContent ou uma variável
			}
			case "TimeInterval_S": {
				var t = term as TimeInterval
				return new TimeInterval_S(t.start.convertToSeconds, t.end.convertToSeconds)
			}
			case "Timeout_S": {
				var t = term as Timeout
				return new Timeout_S(t.seconds)
			}
			case "WeekDaysInterval_S": {
				var t = term as WeekDaysInterval
				return new WeekDaysInterval_S(t.start.toString, t.end.toString)
			}
			default: {
				println("unknown: " + typeTerm)
				return null;
			}
		}

	}

	def String getXpathFromMessageContent(MessageContent msgContent) {
		if (msgContent.variable !== null) {
			return msgContent.variable.name.toString
		} else if (msgContent.content !== null) {
			return msgContent.content.toString
		}
		return "Unknown"
	}

	// identify the type of the term and map from Jabuti Term to solidity struct type
	def static String getTermType(Term tm) {

		val termType = tm.eClass().getName()
		if (termType.equalsIgnoreCase("WeekDaysInterval") || termType.equalsIgnoreCase("TimeInterval") ||
			termType.equalsIgnoreCase("Timeout") || termType.equalsIgnoreCase("SessionInterval")) {
			return termType + "_S" // WeekDaysInterval | TimeInterval | Timeout | SessionInterval
		} // ================================= MaxNumberOfOperation	================================= 
		else if (termType.equalsIgnoreCase("MaxNumberOfOperation")) {
			val maxNumberOfOperation = tm as MaxNumberOfOperation

			if (maxNumberOfOperation.perTime !== null) {
				return termType + "ByTime_S" // MaxNumberOfOperationByTime
			}
			return termType + "_S" // MaxNumberOfOperation
		} // ================================= MessageContent =================================
		else if (termType.equalsIgnoreCase("MessageContent")) {

			// 'MessageContent' '(' returnType= DataType ":" (content=STRING | variable=[Variable]) (comparisonOperator=ComparisonOperator expression=Expression ('per' timeUnit=TimeUnit)?)?  ')' 
			val messageContent = tm as MessageContent

			if (messageContent.expression === null) {
				// if (messageContent.content !== null) {
				if (messageContent.returnType === DataType.TEXT) {
					return termType + "_onlyXPath_String_S" // MessageContent_onlyXPath_String
				} else if (messageContent.returnType === DataType.NUMBER) {
					return termType + "_onlyXPath_Number_S" // MessageContent_onlyXPath_Number
				} else if (messageContent.returnType === DataType.BOOLEAN) {
					return termType + "_onlyXPath_Boolean_S" // MessageContent_onlyXPath_Boolean
				}
			} else if (messageContent.perTime === null) {
				if (messageContent.returnType === DataType.TEXT) {
					return termType + "_String_S" // MessageContent_String
				} else if (messageContent.returnType === DataType.NUMBER) {
					return termType + "_Number_S" // MessageContent_Number
				} else if (messageContent.returnType === DataType.BOOLEAN) {
					return termType + "_Boolean_S" // MessageContent_Boolean
				}
			} else {
				if (messageContent.returnType === DataType.NUMBER) {
					return termType + "_Number_PerTime_S" // MessageContent_Number_PerTime
				} else {
					return "//MessageContent_Number_PerTime is used only to numeric type"
				}
			}
		}
	}

//======================================================================================================
// ================================ GET THE VARIABLES FROM EXPRESSION ================================	
	def void getVariable_ExpressionType(Expression expr, String var_name) {
		exprContent_temp = newArrayList
		if (expr !== null) {
			expr.getVariableContent_Expression // neste ponto a variavel exprContent_temp recebe o conteúdo da expressão 
			variablesMap.put(var_name, new VarExpr(var_name, "unknown", exprContent_temp))

			// verify if the expression contains some logical, comparison o Negation operator			
			for (s : exprContent_temp) {
				if (comparison_symbols.contains(s) || logical_symbols.contains(s) || s.equals("!")) {
					variablesMap.get(var_name).type = "bool"
					return
				}
			}
			for (item : exprContent_temp) {
				if (item.contains("\"")) {
					variablesMap.get(var_name).type = "String"
					return
				}
			}
			variablesMap.get(var_name).type = "uint32"
			return
		}
	}

	def ArrayList<String> getVariableContent_Expression(Expression expr) {
		switch expr {
			ParenthesizedExpression: {
				exprContent_temp.add("(")
				getVariableContent_Expression(expr.expression)
				exprContent_temp.add(")")
			}
			BinaryOperator: {
				getVariableContent_Expression(expr.left)
				exprContent_temp.add(expr.symbol)
				getVariableContent_Expression(expr.right)
			}
			UnaryOperator: {
				exprContent_temp.add(expr.symbol)
				getVariableContent_Expression(expr.expression)
			}
			VariableValue: {
				exprContent_temp.add(expr.value.name)
			}
			LiteralValue: {
				if (expr instanceof StringValue) {
					var aux = expr as StringValue
					exprContent_temp.add("\"" + aux.value + "\"")
				} else if (expr instanceof NumericValue) {
					var aux = expr as NumericValue
					exprContent_temp.add(aux.value.toString)
				}
			}
			default: {
				exprContent_temp.add("unknown")
			}
		}
		// return adicionado para ser usando quando for chamado pelo função que cria termos
		return exprContent_temp
	}

// ===========================================================================================================
// ====================== GET VARIABLES BASED IN THE TERMS BLOCK)  ============================	
	def void getVariableContent_Term(Term term, String var_name) {
		if (term !== null) {
			val termType = term.getTermType // call the method to identify the type of the term
			var term_S = buildTheTermStruct_S(termType, term)
			variablesMap.put(var_name, new VarTerm(var_name, termType, term_S))
		}

	}

	def List<String> getTheTypesOfTermsInUse() {

		for (v : variablesMap.values) {
			if (v !== null) {
				if (v instanceof VarTerm) {
					val termTemp = v as VarTerm;
					if (!termsTypesInUse.contains(termTemp.type)) {
						termsTypesInUse.add(termTemp.type);
					}
				}
			}
		}

		// add the types of terms used in the clauses block
		for (cl : clauses) {
			for (termName : cl.termsList.getTermTypeUniqueValues) {
				if (!termsTypesInUse.contains(termName)) {
					termsTypesInUse.add(termName);
				}
			}
		}

		return termsTypesInUse;
	}

	// ================================ General methods ============================
	def void increment_paramCounter_if() {
		paramCounter_if++;
	}

	def void reset_paramCounter_if() {
		paramCounter_if=0;
	}
	
	def void incrementCounter() {
		counter++
	}

	def void resetCounter() {
		counter = 0;
	}

	def String removeTermSuffix(String str) {
		return str.substring(0, str.length - 2)
	}

	def long toTimestamp(String datetime) {
		val format = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss")
		format.parse(datetime).time / 1000
	}

	def long convertToSeconds2(String timeString) {
		val localTime = LocalTime.parse(timeString);
		val localDateTime = LocalDateTime.of(LocalDate.now(), localTime);
		val timestamp = Timestamp.valueOf(localDateTime);
		return timestamp.time
	}
	
	def long convertToSeconds(String timeString) {
    val localTime = LocalTime.parse(timeString) // Converte a string para LocalTime
    val secondsOfDay = localTime.toSecondOfDay  // Obtém o total de segundos desde a meia-noite
    return secondsOfDay // Retorna apenas os segundos
}

//	def static boolean isNumeric(String str) {
//		try {
//			Integer.parseInt(str)
//			return true
//		} catch (NumberFormatException e) {
//			try {
//				Double.parseDouble(str)
//				return true
//			} catch (NumberFormatException e1) {
//				return false
//			}
//		}
//	}
// ===========================================================================================================
// ======================== METHODS PARA IMPRIMIR O CONTEUDO DAS VARIAVEIS E TERMOS ========================== 
	def void printClause() {
		clauses.forEach [ cl |
			println("termos:")
			cl.termsList.forEach [ entry |
				println(entry)
			]
			println("operadores lógicos:")
			cl.logicalOperators.forEach [ lp |
				println(lp)
			]
		]
	}

	def void printVariablesMapContent() {
		println("\n\n")
		println("----")
		variablesMap.forEach [ p1, p2 |
			if (p2 instanceof VarExpr) {
				print(p2.type + " " + p2.name + " = ")
				p2.content.forEach[p|print(" " + p.toString)]
			}
			if (p2 instanceof VarTerm) {
				(p2.term).printTermStruct
			}
			println("")
		]
		println("----")
	}

	def void printTermStruct(TermStruct term) {

		println("tipo da classe" + term.class.simpleName)

		switch term {
			MaxNumberOfOperation_S: {
				println("MaxNumberOfOperation_S")
			}
			MaxNumberOfOperationByTime_S: {
				println("MaxNumberOfOperationByTime_S")
			}
			MessageContent_Boolean_S: {
				println("MessageContent_Boolean_S")
			}
			MessageContent_Number_PerTime_S: {
				println("MessageContent_Number_PerTime_S")
			}
			MessageContent_Number_S: {
				println("MessageContent_Number_S")
			}
			MessageContent_onlyXPath_Boolean_S: {
				println("MessageContent_onlyXPath_Boolean_S")
			}
			MessageContent_onlyXPath_Number_S: {
				println("MessageContent_onlyXPath_Number_S")
			}
			MessageContent_onlyXPath_String_S: {
				println("MessageContent_onlyXPath_String_S")
			}
			MessageContent_String_S: {
				println("MessageContent_String_S")
			}
			SessionInterval_S: {
				println("SessionInterval_S")
			}
			TimeInterval_S: {
				println("TimeInterval_S")
			}
			Timeout_S: {
				println("Timeout_S")
			}
			default: {
				println("unknown: " + term.class.simpleName)
			}
		}

	}

}